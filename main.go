package main

import (
	"github.com/bilbercode/protoc-gen-prokaf/prokaf"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"google.golang.org/protobuf/compiler/protogen"
)

var (
	ctx          = protogen.GoIdent{GoImportPath: "context"}
	prokafIndent = protogen.GoIdent{GoImportPath: "github.com/bilbercode/protoc-gen-prokaf/prokaf"}
	proto        = protogen.GoIdent{GoImportPath: "google.golang.org/protobuf/proto"}
	title        = cases.Title(language.English)
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, f := range plugin.Files {
			GenerateContent(plugin, f)
		}
		return nil
	})
}

func GenerateContent(gen *protogen.Plugin, file *protogen.File) {
	if !file.Generate {
		return
	}

	var events []*protogen.Message

	for _, msg := range file.Messages {
		if msg.Desc.Options().ProtoReflect().Has(prokaf.E_Event.TypeDescriptor()) {
			events = append(events, msg)
		}
	}

	if len(events) == 0 {
		return
	}

	f := gen.NewGeneratedFile(file.GeneratedFilenamePrefix+".pk.pb.go", file.GoImportPath)
	f.P("// Code generated by protoc-gen-prokaf. NO NOT EDIT.")
	f.P("// versions:")
	f.P("//  protoc-gen-prokaf: 0.1.0")
	f.P("//  protoc: ",
		gen.Request.CompilerVersion.GetMajor(), ".",
		gen.Request.CompilerVersion.GetMinor(), ".",
		gen.Request.GetCompilerVersion().GetPatch(),
	)
	f.P("// source: " + file.Desc.Path())
	f.P()
	f.P("package ", file.GoPackageName)
	f.P()

	generateInterfaces(events, file, f)
	generateUnimplementedConsumer(events, f)
	generateProKafRegistrationFunc(events, file, f)
	generateProducerService(events, file, f)
}

func generateInterfaces(events []*protogen.Message, file *protogen.File, g *protogen.GeneratedFile) {

	g.P("type ProKaf" + title.String(string(file.GoPackageName)) + "ConsumerService interface {")
	for _, method := range events {
		g.P("Consume" + string(method.Desc.Name()) + "(ctx " + g.QualifiedGoIdent(prokafIndent) +
			"Context, in *" + g.QualifiedGoIdent(method.GoIdent) + ", ack func(err error)) error")
	}
	g.P("mustImplementUnimplementedConsumer()")
	g.P("}")
	g.P()
	g.P("type ProKaf" + title.String(string(file.GoPackageName)) + "ProducerService interface {")
	for _, method := range events {
		g.P("Produce" + string(method.Desc.Name()) + "(context " + g.QualifiedGoIdent(ctx) +
			"Context, out *" + g.QualifiedGoIdent(method.GoIdent) + ", topic string, ack func(err error), options ..." +
			g.QualifiedGoIdent(prokafIndent) + "MessageOption) error")
	}
	g.P("}")
	g.P()
}

func generateUnimplementedConsumer(events []*protogen.Message, g *protogen.GeneratedFile) {
	g.P("type UnimplementedConsumer struct { }")
	g.P()
	for _, event := range events {
		g.P("func (*UnimplementedConsumer) Consume" + string(event.Desc.Name()) + "(_ " +
			g.QualifiedGoIdent(ctx) + "Context, _ *" + g.QualifiedGoIdent(event.GoIdent) +
			", ack func(err error)) error {")
		g.P("ack(nil)")
		g.P("return nil")
		g.P("}")
		g.P()
	}

	g.P("func (*UnimplementedConsumer) mustImplementUnimplementedConsumer() { }")
	g.P()

}

func generateProKafRegistrationFunc(events []*protogen.Message, file *protogen.File, g *protogen.GeneratedFile) {
	g.P("func RegisterProKafConsumerHandlersFromService(svc ProKaf" + title.String(string(file.GoPackageName)) +
		"ConsumerService, pk " + g.QualifiedGoIdent(prokafIndent) + "Client) {")
	for _, event := range events {
		fn := event.Desc.FullName()
		g.P("pk.AddRegistryEntry(\"" + string(fn) +
			"\", func(ctx prokaf.Context, dec " + g.QualifiedGoIdent(prokafIndent) + "MessageDecoder, ack func(err error)) error {")
		g.P("in := new(" + event.Desc.Name() + ")")
		g.P("err := dec(in)")
		g.P("if err != nil {")
		g.P("return err")
		g.P("}")
		g.P("return svc." + "Consume" + event.Desc.Name() + "(ctx, in, ack)")
		g.P("})")
	}
	g.P("}")
	g.P()
}

func generateProducerService(events []*protogen.Message, file *protogen.File, g *protogen.GeneratedFile) {
	structName := "proKaf" + title.String(string(file.GoPackageName)) + "ProducerService"

	g.P("func NewProKafProducer(c " + g.QualifiedGoIdent(prokafIndent) + "Client) ProKaf" +
		title.String(string(file.GoPackageName)) + "ProducerService {")
	g.P("return &" + structName + "{ client: c }")
	g.P("}")

	g.P("type " + structName + " struct {")
	g.P("client " + g.QualifiedGoIdent(prokafIndent) + "Client")
	g.P("}")
	g.P()
	for _, event := range events {
		g.P("func (x *" + structName + ") Produce" + string(event.Desc.Name()) + "(ctx " + g.QualifiedGoIdent(ctx) +
			"Context, out *" + g.QualifiedGoIdent(event.GoIdent) + ", topic string, ack func(err error), options ..." +
			g.QualifiedGoIdent(prokafIndent) + "MessageOption) error {")
		g.P("return x.client.ConsumeMessageProduce(ctx, out, topic, ack, options...)")
		g.P("}")
	}
	g.P()

}
